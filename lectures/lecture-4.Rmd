---
title: 'ARCH/GARCH модели <br> "Количественные финансы" '
author: "Салихов Марсель (marcel.salikhov@gmail.com)"
date: "2021-01-20"
output:
  slidy_presentation:
    css: styles.css
    footer: НИУ ВШЭ. Салихов Марсель (marcel.salikhov@gmail.com)
    lib_dir: libs
    self_contained: no
    
---

## Цели лекции 

+ понять, что такое волатильность и как ее можно оценивать
+ понять основные принципы моделей авторегрессионной условной гетероскедастичности (ARCH)
+ научиться тестировать "ARCH-эффект" в R
+ научиться симулировать ARCH-модели 
+ научиться оценивать ARCH-модели на финансовых данных в R c помощью пакетов `fGarch` и `rugarch`
+ понять отличия ARCH и GARCH моделей
+ научиться строить прогнозы для GARCH моделей


```{r setup, cache=FALSE, echo=FALSE, message=FALSE, warning=FALSE}

library("RColorBrewer")    # brewer.pal
library("knitr")           # opts_chunk
library(QuantTools)
library(forecast)
require(tseries)
require(fGarch)
require(rugarch)
require(xts)


# color palette
palette(brewer.pal(6, "Set1"))

opts_chunk$set(fig.width=12, fig.height=7)
opts_chunk$set(cache=TRUE, fig.align="center", comment=NA, echo=TRUE, tidy=FALSE, error=TRUE, warning=FALSE)

# преобразовать объект xts в dataframe с сохранением индекса даты
XtstoDf <- function(ts, ...){ 
  df <- as.data.frame(ts)
  df$date <- time(ts)
  return(df)
}
# encapsulate the plotting commands into a function so that we don't have to repeat ourselves
fancy.plot <- function(x, y, hguide=0, vguide=0, type = "p", col = "black", pch = 1, cex = 1, ...) {
    # set up plot region
    plot(x, y, type="n", axes=FALSE, ...)
    
    # add axes
    Axis(x, side=1, lwd=0, lwd.ticks=1, labels=TRUE)
    Axis(y, side=2, lwd=0, lwd.ticks=1, labels=TRUE)
    Axis(x, side=3, lwd=0, lwd.ticks=1, labels=FALSE)
    Axis(y, side=4, lwd=0, lwd.ticks=1, labels=FALSE)
    
    # add horizontal guide lines
    usr <- par("usr")
    if (hguide > 0) {
        abline(h=seq(usr[3], usr[4], length.out=hguide+2)[-c(1,hguide+2)], col="gray")
    }
    if (vguide > 0) {
        abline(v=seq(usr[1], usr[2], length.out=vguide+2)[-c(1,vguide+2)], col="gray")
    }

    # add the data
    if (type == "l") {
        lines(x, y, col=col)
    } else if (type == "p") {
        points(x, y, cex=cex, pch=pch, col=col)
    }
    
    # add frame
    box()
}

load('../.RData')
```

## Выводы по ARMA-моделям

Напоминание из прошлой лекции: 

+ Мы используем PACF для определения примерного порядка AR-моделей (последний значимый лаг на PACF определяет порядок модели -- $p$)
+ Мы используем ACF для определения ориентировочного порядка MA-моделей (последний значимый лаг на АСF определяет порядок модели -- $q$). 
+ Информационные критерии (AIC, BIC) часто используются для выбора оптимальной модели ARMA. Эти критерии "штрафуют" модели за сложность (количество оцениваемых параметров). Информационнный критирей пытается сбалансировать  in-sample точность модели и ее сложность. 
+ ARMA модели позволяют использовать меньше параметров, чем AR или MA по отдельности.  
+ **Все ARMA модели не позволяют моделировать меняющуюся во времени волатильность**. Поэтому они в принципе не могут моделировать кластеризацию волатильности. В ARMA моделях условная дисперсия является постоянной. 

## Волатильность

* Волатильность -- важное понятие в финансах, так как является синонимом понятия риск. 
* Волатильность не наблюдаема. Поэтому мы используем различные прокси для оценки волатильности. 
* Волатильность имеет широкое использование в различных приложениях: 
    + **Ценообразование опционов**. В модели Black-Scholes стоимость опционов зависит напрямую от волатильности базового актива. 
    + **Риск-менеджмент**. Волатильность используется при расчете показателей VaR (Value at Risk), ES (Expected Shortfall), показателя Шарпа (Sharpe Ratio) и других стандартных параметров риск-менеджмента. 
    + **Торгуемые финансовые инструменты**. Волатильность можно торговать напрямую (к примеру, фьючерсы VIX и связанные с ними ETF), но все еще экзотика для России (на Московской Бирже торгуются фьючерcы на индексы волатильности RVI). 
* Волатильность может быть проще прогнозировать, чем саму доходность. 

**Итог**: если мы умеем прогнозировать волатильность, то мы можем более аккуратно оценивать стоимость опционов, создавать более продвинутые системы риск-менеджмента и можем создавать стратегии для торговли волатильностью. 

## Характеристики волатильности 

+ **Кластеры волатильности** -- волатильность высокая в определенные моменты времени, и низкая -- в другие. 
+ Волатильность меняется непрерывным образом, резкие скачки волатильности возможны, но  редки. 
+ Волательность не может быть бесконечной, она изменяется в определенном диапазоне. То есть волатильность -- стационарна. 
+ Волатильность обычно реагирует по разному на значительное повышение в цене и значительное снижение в цене. 

## Индекс VIX

+ Примером индекса волатильности является VIX -- индекс, рассчитываемый Chicago Board Options Exchange (CBOE) рыночные ожидания 30-дневной волатильности.
+ Индекс VIX конструируется из оценок подразумеваемой волатильности набора опционов на фондовый индекс SP&500. В этом смысле, VIX представляет собой "среднюю" величину подразумеваемой волатильности индекса S& P500. 
+ Сам по себе VIX не является торгуемым инструментом, а лишь отражает показатели группы опционов. 

```{r, message=FALSE, warning=FALSE}
require(quantmod)
require(highcharter)
getSymbols('VIXCLS', src = 'FRED')
hchart(VIXCLS)
```

## Волатильность для акций

Пусть мы оцениваем волатильность акций Роснефти. Мы можем оценить волатильность по разным данным: 1) дневная доходность акций за каждый торговый день 2) внутридневная динамика торгов 3) стоимость опционов на акции Роснефти (если они есть). 
Эти три источника дают три возможных оценки волатильности: 

+ **Волатильность как условное стандартное отклонение ежедневных доходностей**. Это стандартное определение волатильности, которое мы будем использовать сегодня. 
+ **Подразумевая волатильность (implied volatility)**. Используя рыночные цены опционов и одну из моделей ценообразования опционов (к примеру, Black-Scholes), мы можем оценить волатильность. Однако это оценка зависит от модели, которую вы используете для определения цены опциона. 
+ **Реализованная волатильность**. Если у вас есть high frequency данные, вы можете оценивать внутридневную волатильность доходностей. К примеру, вы можете использовать, 5 минутные промежутки времени, для того, чтобы оценить дневную волатильность. 

Обычно волатильность сообщается на годовом уровне (% в год). Если вы оценили дневную волатильность, то вы можете оценить годовую волатильность, умножив ее на $\sqrt{252}$, то есть квадратный корень из количества торговых дней в году (примерно равно 16) 



## Условная гетероскедастичность (Conditional Heteroskedasticity)

+ Серия является **гетероскедастичным**, если определенные подвыборки имеют разную дисперсию. 

К примеру, если нестационарный временной ряд имеет выраженную сезонность или устойчивый тренд, то дисперсия ряда изменяется вместе с сезонностью или трендом. Такая регулярность приводит к гетероскедастичности ряда. Почему? 

Структура финансового рынка и поведение участников приводит к дополнительным причинам, почему увеличение дисперсии приводит к еще большему увеличению дисперсии в реальной жизни. К примеру, если большое количество участников использует стратегию "защиты" портфеля от снижения стоимости, то падение рынка приводит к автоматическим продажам и росту спросу на инструменты "защиты" (опционы) -- то есть, к росту волатильности. Пример - октябрь 1987 года. 

+ Если гетероскедастичность имеет автокорреляцию, то есть **условна** в зависимости от периода роста волатильности, тогда наблюдается **условная гетероскедастичность**. 

## Условное (conditional) среднее и дисперсия 

Пусть есть стационарная серия доходности $r_t$, тогда 

+ Безусловное среднее (`unconditional mean`) -- $E(r_t)$ -- ожидаемое значение доходности, оно не зависит от времени. 
+ Условное среднее (`conditional mean`) -- это ожидаемое значение доходности в момент времени $t$, учитывая всю более раннюю информацию $E(r_t|\Omega_{t-1})$. Условное среднее зависит от времени. Модели ARIMA оценивают условное среднее, так как учитывают предыдущую информацию. 

Ту же самую логику можно использовать для волатильности: 

+ Безусловная дисперсия (`unconditional variance`) -- $\sigma^2 = Var(r_t)$ -- рассчитывается по стандартной формуле и не зависит от времени. 
+ Условная дисперсия (`conditioanl variance`) -- $\sigma_t^2 = Var_t(r_t|\Omega_{t-1})$ -- оценки дисперсии в момент времени $t$ с учетом всей предыдущей информации. 
 

## Идентификация условной гетероскедастичности

+ Эффект условной гетероскедастичности сложно оценить по корелограммам. 
+ Можно использовать модели волатильности, такие как ARCH или GARCH. 

```{r, cache=FALSE, message=FALSE, warning=FALSE}
plot.xts(MICEX.rtn, type = 'l',main  = 'Доходность индекса ММВБ')
t.test(MICEX.rtn) # тестируем среднее доходнстей

```

Cудя по t-тесту, мы принимаем гипотезу о том, что среднее доходности равно 0. 

## ARCH-модель 

+ **A**uto
+ **R**egressive
+ **C**onditional
+ **H**eteroskedastic



## Описание ARCH-модели 

+ Мы знаем, что модели ARMA не позволяют моделировать CH-эффект. Однако почему не попробовать моделировать **условную дисперсию** серии с помощью модели ARMA? 

Это и есть базовый принцип ARCH.

Пусть временной ряд ${\epsilon_t}$ имеет следующий вид: 

$$ \epsilon_t = \sigma_t w_t $$
где $w_t$ -- белый шум с нулевым средним и единичной дисперсией (белый шум может иметь нормальное распределение, но это не обязательно, распределение может быть и иным).

Часть $\sigma_t$ -- условная дисперсия (**conditional variance**), она имеет вид: 

$$\sigma_t^2 = a_0 + a_1 \epsilon_{t-1}^2 $$
$a_0$ и $a_1$ -- это параметры модели, которые необходимо оценить. 

Условная дисперсия ряда по определению равно $\sigma_t^2 = Var(\epsilon_t | e_{t-1}, \ldots)$ ;

В этом случае ряд ${\epsilon_t}$ является процессом ARCH(1). Можно записать модель в следующем виде: 

$$\epsilon_t = w_t \sqrt{a_0 + a_1 \epsilon_{t-1}^2} $$
$a_0 >0$ и $a_1 > 0$ для того, чтобы часть под корнем была больше 0.

$a_0 + a_1<1$ для того, чтобы ряд оставался стационарным с конечной дисперсией. 

+ **Процесс ${\epsilon_t}$ является процессом ARCH(1)**. 


## Почему ARCH моделирует волатильность?

Немного математики: 

$$ Var(\epsilon_t) = E[\epsilon_t^2] - (E[\epsilon_t])^2 = E[\epsilon_t^2] =E[w_t^2]E[a_0 + a_1 \epsilon_{t-1}^2]= $$
$$=E[a_0 + a_1 \epsilon_{t-1}^2]  = a_0 + a_1 Var(\epsilon_{t-1}) = a_0 + a_1 \epsilon_{t-1}^2 $$

учитывая, что среднее $w_t$ равно 0, дисперсия -- 1, а $E[\epsilon_t] = 0$

+ **Дисперсия ARCH(1) модели является AR(1)-процессом**. 


## Когда можно использовать ARCH?

+ Мы использовали корелограмму доходностей для идентификации AR(1)-процесса. Точно также можно использовать корелограмму **квадратов доходностей** для идентификации ARCH
+ ARCH необходимо использовать, если вы уже подобрали адекватную модель, которая "оставляет" после себя остатки, более или менее похожие на белый шум. **С начала необходимо определить модель для среднего доходностей, а потом моделировать дисперсию**.  
+ ARCH не имеет смысла использовать для серий, которые имеют сезонные и/или трендовые эффекты. С начала "уберите" сезонность/тренд с помощью ARIMA (SARIMA), экзогенных регрессоров и прочих моделей, а после этого оценивайте ARCH.

## Достоинства и недостатки ARCH

Достоинства: 

1. Модель может "создавать" кластеры волатильности
2. Модель может "создавать" heavy tails

Недостатки: 

1. Модель трактует положительные и отрицательные шоки одинаковым образом с точки зрения влияния на волатильность. Эмпирические наблюдения и здравый смысл говорят, что эти шоки различны. 
2. Модель ARCH накладывает достаточно сильные ограничения на значения коэффициентов модели. Это ограничивает возможности моделировать более высокие моменты (к примеру, избыточный эксцесс). ARCH хорошо моделирует вспышки волатильности (burst), но не очень хорошо моделирует более длительные смены режимов волатильности. 
3. Модель ARCH не дает возможность оценки источников шоков, это просто механистический способ оценки поведения условной дисперсии. 
4. Модель ARCH недооценивает волатильность, так как достаточно медленно реагирует на большие по значению шоки. 
5. Модель на фактических требует достаточно большого количество параметров для оценки, что увеличивает вероятность overfitting. 

## ARCH(p)

Модель ARCH порядка $p$ имеет следующий вид: 

$$\sigma_t^2 = w_t \sqrt{a_0 + \sum_{i=1}^{p} a_i \epsilon_{t-i}^2} $$

+ Модель ARCH(p) -- это моделирование дисперсии ряда как AR(p). 

## Тестирование ARCH-эффекта

Пусть уравнение для среднего выглядит следующим образом: $a_t = r + \mu_t$. 
Мы можем использовать квадраты остатков ($a_t^2$), чтобы проверить серию на условную гетерокседастичность (ARCH-эффект). Есть два варианта тестирования ARCH-эффекта: 

1. Использовать тест Льюнга-Бокса (Ljung-Box test) для серии $\{a_t^2\}$ -- мы проходили этот тест в ARMA-моделях
2. Использовать тест множителей Лагранжа (см. *Engle (1982)*). Этот тест эквивалентен обычному F-тесту на тестирование гипотезы ($\alpha_i = 0$) в уравнении: 

$$ a_t^2 = \alpha _0 + \alpha_1 a_{t-1}^2 +\ldots + \alpha_{t-m}^2 + \epsilon_t, t = m +1, ..., T $$

<!-- Код теста LM для R: -->

<!-- ```{r} -->
<!-- "archTest" <- function(rtn,m=10){ -->
<!-- #  Провести тест множителей Лагранжа для оценки ARCH-эффекта в ряде  -->
<!-- # rtn: серия доходностей -->
<!-- # m: порядок AR -->
<!-- # -->
<!--   y= (rtn - mean(rtn))^2 -->
<!--   T = length(rtn) -->
<!--   atsq = y[(m+1):T] -->
<!--   x = matrix(0,(T-m),m) -->
<!--   for (i in 1:m){ -->
<!--     x[,i] = y[(m+1-i):(T-i)] -->
<!--    }  -->
<!--    md = lm(atsq~x) -->
<!--    summary(md) -->
<!-- } -->


<!-- ``` -->

## Проверка ARCH-эффекта для доходностей индекса ММВБ 

```{r, warning=FALSE}
require(FinTS)
y <- MICEX.rtn - mean(MICEX.rtn)
Box.test(y^2,lag = 10,type = 'Ljung')
ArchTest(y,12) 

```

Оба теста указывают на присутствие ARCH-эффекта в серии 

## Определение порядка ARCH модели 

+ Мы можем использовать PACF _квадратов_ доходностей, чтобы оценить порядок ARCH модели. 

```{r}
Pacf(y^2)
```

Можем оценить ARMA(1,1) модель для среднего доходностей и посмотреть на квадраты остатков этой модели: 

```{r}
arma11 <- Arima(MICEX.rtn, order=c(1, 0, 1))
Pacf(resid(arma11)^2)
```

Как видно, требуется достаточно много лагов (порядок модели), чтобы использовать ARCH.

## Симулирование AR(1) + ARCH(1)

AR(1) модель для среднего и ARCH(1) для дисперсии можно симулировать следующим образом: 

```{r}

n = 10200 #
e = rnorm(n)
a = e # ARCH
y = e # AR + ARCH
sig2 = e^2 # условная дисперсия
# параметры для ARCH
omega = 1
alpha = 0.55
#параметры для AR
phi = 0.8
mu = 0.1
omega/(1-alpha) # безусловное ст. отклонение
sqrt(omega/(1-alpha))

set.seed("1234")
for (t in 2:n)
{
  a[t] = sqrt(sig2[t])*e[t]
  y[t] = mu + phi*(y[t-1]-mu) + a[t] # моделирование AR
  sig2[t+1] = omega + alpha * a[t]^2 # моделирование ARCH
}

par(mfrow=c(2,4))
plot(e[10001:n],type="l",xlab="t",ylab=expression(epsilon),main="(a) белый шум")
plot(sqrt(sig2[10001:n]),type="l",xlab="t",ylab=expression(sigma[t]),
     main="(b) условная дисперсия")
plot(a[10001:n],type="l",xlab="t",ylab="a",main="(c) ARCH")
plot(y[10001:n],type="l",xlab="t",ylab="y",main="(d) AR+ARCH")
acf(a[10001:n],main="(e) ARCH")
acf(a[10001:n]^2,main="(f) ARCH squared")
acf(y[10001:n],main="(g) AR+ARCH")
acf(y[10001:n]^2,main="(h) AR+ARCH squared")
par(mfrow=c(1,1))
```

## Оценка ARCH-модели

Оценим ARCH(1)-модель для доходностей ММВБ при допущении о том, что среднее доходностей является константой.
Используем помощью функцию `garchFit` из пакета `fGarch`.


```{r}

library(fGarch)
arch1 <- garchFit(~1+garch(1,0),data=MICEX.rtn,trace=F)
summary(arch1)
res  <- residuals(arch1,standardize=T) # используем стандартизированные остатки для диагностики модели 
Acf(res,lag=20)
Pacf(res,lag=20)
# plot(arch1) диагностические графики для модели 
plot(arch1, which = 13) # QQ-Plot of Standardized Residuals   
```

Оцененная модель имеет вид: 

$$ r_t = 0.00044228 + a_t, \sigma^2 = 0.00012838 + 0.18042783 a_{t-1}^2 $$
Все коэффициенты являются значимыми. 
ACF и PACF указывают на отсутствие автокорреляции в остатках 

## Оценка ARCH(1) c распределением Стьюдента для шоков

Та же самая модель с t-распределением Стьюдента для моделирования шоков серии. 

```{r}
arch1_student <- garchFit(~1+garch(1,0),data=MICEX.rtn,trace=F, cond.dist="std")
summary(arch1_student)
res  <- residuals(arch1_student,standardize=T) # используем стандартизированные остатки
Acf(res,lag=20)
Pacf(res,lag=20)
plot(arch1_student, which = 13) # QQ-Plot of Standardized Residuals   

```

Использование распределения с более "тяжелыми хвостами" несколько уменьшило значение ARCH-коэффициента. 
График квантиль-квантиль также подтверждает, что использование распределения Стьюдента для шоков, приводит к более "нормальным" остаткам модели

## Определение GARCH

+ Если мы используем AR-модель для дисперсии, почему не использовать и MA-модель? Это и есть основа **GARCH (Generalised Autoregressive Conditional Heteroskedastic Model)**. 

Временной ряд ${\epsilon_t}$ имеет следующий вид: 

$$ \epsilon_t = \sigma_t w_t $$

 где $w_t$ -- белый шум с нулевым средним и единичной дисперсией, а часть $\sigma_t^2$ имеет вид: 
 
$$\sigma_t^2 = a_0 +\sum_{i=1}^{q} a_i \epsilon_{t-i}^2+ \sum_{j=1}^{p} \beta_i \sigma_{t-j}^2  $$

где $\alpha_i$ и $\beta_j$ -- это параметры модели. Процесс $\epsilon_t$ является GARCH(p,q)


+ **GARCH -- это ARMA-процесс для дисперсии серии**. 

## Симулирование GARCH(1,1)

GARCH(1,1) будет иметь следующий вид: 

$$\epsilon_t = \sigma_t w_t $$
$$ \sigma_t^2 = a_0 + a_1 \epsilon_{t-1}^2 + \beta_1 \sigma_{t-1}^2 $$



```{r}
set.seed(2)
# параметры модели 
a0 <- 0.2
a1 <- 0.5
b1 <- 0.3
w <- rnorm(10000) ## белый шум
eps <- rep(0, 10000) ## исходный ряд, пока заполненный нулями 
sigsq <- rep(0, 10000) ## компонента GARCH

for (i in 2:10000) {
   sigsq[i] <- a0 + a1 * (eps[i-1]^2) + b1 * sigsq[i-1]
   eps[i] <- w[i]*sqrt(sigsq[i])
}

plot(eps, type = 'l')
```

+ построим корелограмму получившегося ряда

```{r}
Acf(eps)
```

вроде бы ничего необычного. Но если мы построим корелограмму квадратов рядов, то увидим выраженное убывание на последующих лагах (характеристика AR-процесса)


```{r}
Acf(eps^2)
Pacf(eps^2)
```


## Оценка симулированной GARCH(1,1)-модели 

Мы можем также использовать функцию `garch` из пакета `tseries`

```{r}
library(tseries)
eps.garch <- garch(eps, trace=FALSE)
summary(eps.garch)
confint(eps.garch)
```

+ Коэффициенты отличаются значимым образом от 0. 
+ Доверительные интервалы включат "настоящие" значения коэффициентов

## Оценка GARCH(1,1) для индекса ММВБ

Оценим GARCH(1,1) при допущении о том, что среднее доходностей является константой: 

```{r}
library(fGarch)
garch11 <- fGarch::garchFit(~1+garch(1,1),data = MICEX.rtn,trace=F) # часть ~1 говорит о том, что надо оценивать константу
summary(garch11)
coef(garch11)
v11 = garch11@sigma.t*sqrt(252)*100
plot(index(MICEX.rtn), v11,type='l', xlab= 'год',ylab='% год', main = 'Оценка волатильности индекса ММВБ на основе GARCH(1,1) модели') 

```

Мы можем также использовать критерии AIC/BIC для выбора лучшей GARCH модели 

## Варианты для моделей доходностей 

Мы используем только одну серию для моделирования -- серию фактических доходностей. 
Модель GARCH раскладывает эту серию на три части: 

1. Среднее арифметическое доходности в момент $t$
2. Условная дисперсия в момент времени $t$
3. Шок в момент времени $t$.

Мы можем использовать разные подходы для оценки среднего доходностей (часть 1): 

+ ноль
+ константа (которую нужно оценить)
+ простая авторегрессионная модель -- к примеру, AR(1)
+ ARMA модель 
+ что-то другое. 

Спецификация модели GARCH позволяется определить каким образом, рассчитываются части 2 и 3. 

## Оценка GARCH(1,1) с ARMA-моделью


Мы пришли к выводу, что ARMA(1,1) является оптимальной моделью для серии. 

```{r}

garch_best <- garchFit(~ arma(1,1)+ garch(1,1), data=MICEX.rtn,
                         trace = F, include.mean = TRUE)

```

Предупреждение указывает на то, что оптимизатор не смог найти значения коэффициентов. Поэтому текущие значения коэффициентов не имеют большого смысла. 

## Оценка GARCH(1,1) + ARMA(3,3) для доходностей индекса ММВБ с помощью rugarch

попробуем использовать пакет `rugarch`.
В этом пакете сначала необходимо создать объект, определяющиий тип оцениваемой модели, с помощью функции `ugarchspec`. 
Функция `ugarchfit` уже оценивает непосредственно модель. Для сложных моделей оценка может занимать определенное время. 

```{r}
library(rugarch)
spec = ugarchspec(
                 variance.model=list(garchOrder=c(1,1)),
                 mean.model=list(armaOrder=c(3,3), include.mean=T),
                 distribution.model="sged")

fit = tryCatch(
       ugarchfit
       (
         spec, 
         MICEX.rtn, 
         solver = 'hybrid'
       ), 
       error=function(e) e, 
       warning=function(w) w
     )
(fit)
#plot(fit)
resid <- residuals(fit, standardize = TRUE)
Acf(resid)
Pacf(resid)
v33 <- sqrt(252) * fit@fit$sigma*100
head(v33)
plot(sqrt(252) * fit@fit$sigma, type='l')
plot(fit, which = 1)
```


## Сравнение оценок GARCH разных моделей среднего

сравним оценку волатильности доходностей индекс ММВБ двух разных моделей: 

1. GARCH(1,1) + константа для доходностей
2. GARCH(1,1)+ARMA(3,3)

```{r}
plot(index(MICEX.rtn),v11,type="l",col="red", xlab= 'год', ylab = '% ujl')
lines(index(MICEX.rtn),v33,col="green")
```

Оценки модели очень близки друг к другу. 

## Прогнозирование с помощью GARCH

GARCH модели позволяют строить прогнозы исходной серии и прогнозы для волатильности:


```{r}
fcst = ugarchforecast(fit, n.ahead=10)
plot(fcst, which = 1) # прогноз для ряда
plot(fcst, which = 3) # прогноз для волатильности
```


## Использованные источники: 

1. "An Introduction to Analysis of Financial Data with R" (Ruey S. Tsay)
2. "Statistics and Data Analysis for Financial Engineering" (David Ruppert & David Matteson)
3. Analyzing Financial Data and Implementing Financial Models Using R (Clifford Ang)
4. Forecasting Financial Time Series (Patrick Perry)
5. Generalised Autoregressive Conditional Heteroskedasticity GARCH(p, q) Models for Time Series Analysis (Michael Halls-Moore)
